Dependency injection
Uma forma de isolar as classes, para que a implementação de uma não interfira totalmente
nos testes de outra.

Test Doubles

unit testing -> o que vamos focar nesta cadeira
test doubles -> objectos que ajudam a minimizar a complexidade dos testes e de certa forma ajudar
                a que os testes sejam independentes do resto do sistema. São exemplos:

stubs - providencia respostas pré-programadas. Se a função receber x deverá retornar Y,
        independentemente do resto do sistema

mocks - espectativas quanto à programação. Usam-se diferentes frameworks, para esta cadeira apenas dois:
        - Mockito, em Java
        - Spock, em Groovy

Diferença entre mocks e stubs
Stubs - programados para retornar valores predefinidos
Mocks - é possível testar como a função é chamada, com que argumentos, como é o seu estado, comportamento e quantas vezes
        o método é chamado. JMockit e Spock, por exemplo.

Aula 7 (02/12/2021)

Component Testing
A maior parte das falhas deriva da interação entre unidades de código. Aqui os unit testings
não conseguem apanhar, teremos de usar o teste de interface.
Testar tudo junto (all together testing, big bang testing) se houver uma forte dependencia entre as unidades, quando algo
falhar, se nos for difícil encontrar o bocado que faz falhar, usar o unit testing (step-by-step)

Vantagens do big bang testing / all together testing
Precisamos de poucos testes, executa mais rápido
Os erros não são fáceis de apanhar

Bottom up - combina testes de componentes que convém perguntar primeiro
tOP DOWN - testar o sistema como um todo e recorrendo a mocks

Continuous integration
através de testes de software, builds privados e builds públicos para que exista
colaboração com a equipa.

Mainline - master/main do código no github por exemplo
Develop - branch de desenvolvimento, a usar por todos os colaboradores. só se dá merge
            na main se passar nos testes no escopo privado (unit testing)
Integration build - um build periódico, para garantir que o código modificado por todos
                    continua a funcionar correctamente
Smoke test - testes para garantir que nada foi quebrado aquando do merge do código entre todos

Design Patterns

Factory Method
Definir uma interface para criar um objecto, mas deixar que as subclasses decidam
qual classe instanciar.
Evitar repetições de código e problemas caso esse mesmo código tenha que sofrer alterações.
Assim o código é modificado só num sítio e perpetuado por todo o projecto sem demais problemas

Aula 8 (09/12/2021)

Refactoring
Permite melhorar o desenho e estrutura do software, sem modificar o seu comportamento,
para que exista uma melhor compreensão do que faz e como faz.
Sempre que se faz uma refatorização, convém voltar a correr os testes para que não exista
problemas de quebra de determinados parâmetros.

Code Smells
Algo pode levar a problemas futuros no código e por isso deverá ser feita uma
refactorização no sítio adequado o quanto antes. Não são detectados com base em unit testing.
Um bom site para aprender mais sobre code smells -> refactoring.guru

1 - Bloaters
Quando

Alguns exemplos

Long Method - métodos maiores de 15 linhas normalmente podem ser partidos em várias
              outras partes e não permite uma verificação de erros rápida

Large Classes - normalmente as classes longas são aquelas que fazem de tudo um pouco,
                o que causa alguma confusão no código no geral

Primitive Obsession - uso excessivo de primitivas, não usando os correspondentes objectos

Long Parameter List - métodos que são chamados com uma grande lista de parametros, mais
                        que quatro já não é adequado

Data clumbs - partes diferentes do código possuem grupos de identicas variáveis, originando
                mais erros e mais problemas ao refactorar

2 - Object oriented abusers

Alguns exemplos:

Switch statements - abuso da utilizaçção de switch e de if..else em métodos

Temporary Field - uma classe que utiliza campos temporários, que ao não serem preenchidos
                    podem causar problemas futuros na implementação

Refuse bequest - confusão de subclasses e superclasses que, apesar de usarem os
                    mesmos métodos e atributos, são completamente diferentes. Exemplo:
                    Animal(leg) -> (dog || chair)

Alternative Classes with different interfaces - classes muito idênticas mas com interfaces
                    diferentes

3 - Change Preventers

Alguns exemplos:

Divergent change - necessidade de mudar muitas partes da classe para implementar uma nova
                    feature ou método. É um sinal claro que existem problemas de estrutura no código
                    e também dependências exageradas

Shotgun Surgery - parecido com a anterior, mas em vez de alterar só a classe, altera mais
                    partes do código no seu todo.

Parallel inheritance hierarchies - há necessidade de criar uma subclasse noutro lado do código
                        quando se cria um primeira subclasse. Sinal que há dependências em demasia

4 - Dispensables
Eliminação de código redundante.

Alguns exemplos

Comments - comentários desnecessários, que só poluem o código em si

Duplicate code - em vez disso, criar uma classe ou um método em separado

Lazy class - classe que não faz muito ou nada, que ao ser apagada pouco transtorno traz
        ao código em si

Data classes - classes que só tenham getters e setters

Speculative Generality - implementar código que para já não é necessário, ou seja,
                    há criação de lazy classes e temporary field

5 - Couples
Contribuem para que uma classe tenha bastantes

Alguns exemplos

Feature envy - Necessidade de um método invocar métodos de outras classes para
                poder atuar. Indicação que é necessário transferir métodos para outras classes.

Inappropriate Intimacy - quase o mesmo de cima. É um método que usa atributos de várias
                            outras classes para poder funcionar tal como foi idealizado.

Message chains - correntes de chamamentos entre classes, que poderiam fazer parte de uma classe auxiliar

Middle man - um método intermédio que não altera nenhum atributo

Como encontrar algumas deste code smells automaticamente?
bettercodehub.com, entrar com a conta do github
errorprone.info, desenvolvida pela Google que implementa as regras do Google Standard Guide
fbinfer.com, desenvolvido pelo Facebook
no gradle: id "org.kordamp.gradle.errorprone" version "0.47.0"

Refactoring

1 - Composing Methods

Extract method - extrair linhas repetidas em vários locais e constituir um método em separado
Inline method
Extract variable
Inline
Replace Temporary with Query
Split temporary variables - para uma melhor compreensão do código
Remove assignmments to Parameters - usar e manipular variáveis locais em vez de parâmetros
                            passados ao método
Substitute algorithm - simplificar o código para uma futura manutenção

2 - Moving features between Objects

Move method
Move class
Extract class
Inline class
Hide Delegate - evitar dependências em classes terceiras
Remove middle man
Introduce foreign method
Introduce local extension

3 - Simplifying Conditional Expressions

Decompose conditional
Consolidate conditional expression
Remove control flag
Replace nested conditionals
Introduce null objects
Introduce assertions

4 - Symplifying method calls

5 - Dealing with generalizations

Pull up field
Pull up method
Pull up constructor body
Push down field
Push down method
Extract subclasses
Extract superclasses
Extract interfaces
Colapse hierarchy
Form Template Method
Replace Inheritance with delegation
Replace delegation with inheritance

Aula 9 (16/12/2021)

UML
Diagramas que representam a estrutura e o comportamento da aplicação

Class Diagrams
Representa as classes e relação entre elas, bem como implementar as operações
dos atributos de cada uma.
Modelação conceptual do domínimo do software e os seus componentes
A representação de cada classe vai ao encontro do que se aprende em Base de Dados:
atributos
symbol atributeName : atributeType
atributos com valores por omissão
symbol atributeName = atributeDefaultValue
com o símbolo podendo ser de três tipos:
   "-" para atributos / métodos privados
   "+" para atributos / métodos públicos
   "*" para atributos / métodos protegidos

symbol methodName(listParameters : parametersType) : returnType

Nota:
Para classes ou métodos abstratos, usar os seus nomes em itálico
Há associações bidirecionais (por omissão) ou unidirecionais (usando a seta)
Interfaces: o nome passa a ser <<Interface>> interfaceName e todas as classes que
    a implementarem são ligadas por tracejado
Dependência: representada por uma seta a tracejado, a apontar para a parte necessária

Sequence Diagrams
Representa a interação entre objectos numa ordem sequencial

Lifeline - representa o tempo sequencial (uma linha do tempo)
Actors - qualquer entidade externa que interaja com o sistema
Message - traduzida por uma seta preenchida ou tracejada
Activation - retângulo em cima da lifeline que representa o período que demora a
            processar o pedido

State Diagrams
Representa os diversos estados da aplicação (inicial..final)

Transitions: setas que possuem, na descrição, três coisas: o evento, que é uma chamada
de uma função, um input, ..., uma guard (uma condição que tem de ser verdadeira para que
a transição seja feita) e effect, o efeito da transição do objecto que se estava a manipular