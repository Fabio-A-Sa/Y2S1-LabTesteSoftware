Vou colocar as notas aqui provisoriamente, depois decido se faço um markdown para esta parte da matéria

Aula 4, gravação às @01:17:00 horas

unit testing -> o que vamos focar nesta cadeira
test doubles -> objectos que ajudam a minimizar a complexidade dos testes e de certa forma ajudar
                a que os testes sejam independentes do resto do sistema. São exemplos:

stubs - providencia respostas pré-programadas. Se a função receber x deverá retornar Y,
        independentemente do resto do sistema

mocks - espectativas quanto à programação. Usam-se diferentes frameworks, para esta cadeira apenas dois:
        - Mockito, em Java
        - Spock, em Groovy

Aula 5, gravação (ver hoje de tarde)

Testar o sistema (antigamente):
- testar o código sob o ponto de vista do utilizador;
- escrever código que vai exercitar o código que queremos testar, e colocar esse código na main;
Desvantagens deste método antigo:
- difícil de gerir o sistema
- não dá para fazer um roleback do sistema "estragado" pela manipulação dos testes
- muito manual, quase sem automatização

Atualmente:
Usar Spock and JUnit -> permite que o developer se foque apenas no teste

No JUnit
setup (@Before)
run (@Test)
clean up (@After)

No Spock
setup()
test()
cleanUp()

Bugs and debugging

Human Error - an human action which produces software faults / defeitos
Faults - omissão de software por erro humano
Error - estado não esperado do sistema que eventualmente pode levar a uma falha
Failture - uma falha observada

Bugs ou features?
Perceber as necessidades do cliente pode não estar alinhado com a especificação dada.
Diferentes interpretações (a linguagem natural é ambígua), pode ser bug para um e feature para outro.
Leva a problemas de interpretação e de software
Constante comunicação com o cliente, para especificações precisas

Detalhe para o projecto, 29:45 da aula 5

Uso de testes - para verificar o comportamento do sistema em runtime
Uso de revisões e inspeções - para algo que não é executável, porque os humanos são bons a ler descrições

Quando parar de testar?

Fault injection - adicionar falhas ao código para ver se o conjunto de testes os consegue apanhar.
                  quanto maior o rácio falhas apanhadas / falhas injectadas, mais rigorosos são os testes

Black Box testing - Não sabemos como está implementado o código
White Box testing - Temos acesso ao código, conhece a implementação

White Box Testing:

    Statement coverage;
    Testes que executam os caminhos pelo menos uma vez

    Branch coverage;
    Todas as condições booleanas são avaliadas pelo menos uma vez (não combinadas)

    Path coverage;
    Todas as condições booleanas são avaliadas, com todas as combinações possíveis de
    falso e verdadeiro. Todos os caminhos independentes são executados pelo menos uma vez.

    Condition Coverage:
    As condições booleanas combinadas são testadas com todas as combinações possíveis.
    Exemplo: para if (a and b) eram necessários 4 testes.

Black Box Testing:

    Equivalence partitioning;
    Generalizar os testes para valores que estejam dentro da mesma partição

    Boundary value analysis;
    Avaliar os limites de cada partição, no ponto exato e em valores próximos aos
    valores de fronteira.

Dependency injection
Uma forma de isolar as classes, para que a implementação de uma não interfira totalmente
nos testes de outra. Implica não isolar

Test Doubles
Diferença entre mocks e stubs
Stubs - programados para retornar valores predefinidos
Mocks - é possível testar como a função é chamada, com que argumentos, como é o seu estado, comportamento e quantas vezes
        o método é chamado. JMockit e Spock, por exemplo.

Aula 7 (02/12/2021)

Component Testing
A maior parte das falhas deriva da interação entre unidades de código. Aqui os unit testings
não conseguem apanhar, teremos de usar o teste de interface.
Testar tudo junto (all together testing, big bang testing) se houver uma forte dependencia entre as unidades, quando algo
falhar, se nos for difícil encontrar o bocado que faz falhar, usar o unit testing (step-by-step)

Vantagens do big bang testing / all together testing
Precisamos de poucos testes, executa mais rápido
Os erros não são fáceis de apanhar

Bottom up - combina testes de componentes que convém perguntar primeiro
tOP DOWN - testar o sistema como um todo e recorrendo a mocks

Continuous integration
através de testes de software, builds privados e builds públicos para que exista
colaboração com a equipa.

Mainline - master/main do código no github por exemplo
Develop - branch de desenvolvimento, a usar por todos os colaboradores. só se dá merge
            na main se passar nos testes no escopo privado (unit testing)
Integration build - um build periódico, para garantir que o código modificado por todos
                    continua a funcionar correctamente
Smoke test - testes para garantir que nada foi quebrado aquando do merge do código entre todos


Design Patterns

Factory Method
Definir uma interface para criar um objecto, mas deixar que as subclasses decidam
qual classe instanciar.
Evitar repetições de código e problemas caso esse mesmo código tenha que sofrer alterações.
Assim o código é modificado só num sítio e perpetuado por todo o projecto sem demais problemas


